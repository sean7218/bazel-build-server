use serde::{Deserialize, Serialize};
use url::Url;

use crate::support_types::build_target::BuildTargetIdentifier;

#[derive(Debug, Serialize, Deserialize)]
pub struct BuildTargetSourcesRequest {
    pub targets: Vec<BuildTargetIdentifier>,
}

/// The build target sources request is sent from the client to the server to
/// query for the list of text documents and directories that belong to a
/// build target. The sources response must not include sources that are
/// external to the workspace.
/// [sourcekit-lsp](https://github.com/swiftlang/sourcekit-lsp/blob/main/Sources/BuildServerProtocol/Messages/BuildTargetSourcesRequest.swift)
#[derive(Debug, Serialize, Deserialize)]
pub struct BuildTargetSourcesResponse {
    pub items: Vec<SourcesItem>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SourcesItem {
    pub target: BuildTargetIdentifier,
    pub sources: Vec<SourceItem>,
    pub roots: Option<Vec<Url>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SourceItem {
    /// Either a text document or a directory. A directory entry must end with a
    /// forward slash "/" and a directory entry implies that every nested text
    /// document within the directory belongs to this source item.
    pub uri: Url,

    /// SourceItemKind => 1 = file and 2 = directory
    pub kind: u8, 

    /// Indicates if this source is automatically generated by the build and is
    /// not intended to be manually edited by the user.
    pub generated: bool,

    /// should always be "sourceKit"
    pub data_kind: String, 

    /// If `dataKind` is `sourceKit`, the `data` interpreted as `SourceKitSourceItemData`, otherwise `nil`.
    pub data: SourceKitSourceItemData,
}

#[allow(dead_code)]
#[derive(Debug, Serialize, Deserialize)]
pub enum SourceItemKind {
    File,
    Directory
}

impl SourceItemKind {
    pub fn to_u8(&self) -> u8 {
        match self {
            SourceItemKind::File => 1,
            SourceItemKind::Directory => 2
        }
    }
}

impl SourceItem {
    pub fn from_url(url: &Url) -> Self {
        SourceItem {
            uri: url.clone(),
            kind: SourceItemKind::File.to_u8(), // always assume it is a file 
            generated: false,
            data_kind: String::from("sourceKit"),
            data: SourceKitSourceItemData {
                language: None,
                kind: Some(SourceKitSourceItemKind::Source.to_string()),
                output_path: None,
            },
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SourceKitSourceItemData {
    /// The language of the source file. If `nil`, the language is inferred from the file extension.
    pub language: Option<String>,

    /// The kind of source file that this source item represents. If omitted, the item is assumed to be a normal source file,
    /// ie. omitting this key is equivalent to specifying it as `source`.
    pub kind: Option<String>,

    /// The output path that is used during indexing for this file, ie. the `-index-unit-output-path`, if it is specified
    /// in the compiler arguments or the file that is passed as `-o`, if `-index-unit-output-path` is not specified.
    ///
    /// This allows SourceKit-LSP to remove index entries for source files that are removed from a target but remain
    /// present on disk.
    ///
    /// The server communicates during the initialize handshake whether it populates this property by setting
    /// `outputPathsProvider: true` in `SourceKitInitializeBuildResponseData`.
    pub output_path: Option<String>,
}

#[allow(dead_code)]
pub enum SourceKitSourceItemKind {
  /// A source file that belongs to the target
  Source,

  /// A header file that is clearly associated with one target.
  ///
  /// For example header files in SwiftPM projects are always associated to one target and SwiftPM can provide build
  /// settings for that header file.
  ///
  /// In general, build systems don't need to list all header files in the `buildTarget/sources` request: Semantic
  /// functionality for header files is usually provided by finding a main file that includes the header file and
  /// inferring build settings from it. Listing header files in `buildTarget/sources` allows SourceKit-LSP to provide
  /// semantic functionality for header files if they haven't been included by any main file.
  Header,

  /// A SwiftDocC documentation catalog usually ending in the ".docc" extension.
  DoccCatalog,
}

impl SourceKitSourceItemKind {
    pub fn to_string(&self) -> String {
        match self {
            SourceKitSourceItemKind::Source => String::from("source"),
            SourceKitSourceItemKind::Header => String::from("header"),
            SourceKitSourceItemKind::DoccCatalog => String::from("doccCatalog"),
        }
    }
}
